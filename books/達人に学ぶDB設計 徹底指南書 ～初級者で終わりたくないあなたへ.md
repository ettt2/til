# 達人に学ぶDB設計 徹底指南書 ～初級者で終わりたくないあなたへ

## 読む前に,,,

### 理解していること
- テーブルを分割して一つのテーブルの役割を持たせないようにする
- 配列を保存するときは、テーブルを作成して一つのカラムに一つの値を入れる
- インデックスを貼るとパフォーマンスが上がる、検索対象となる絡むににインデックスを貼る

### 理解していないこと
- NULLをデフォルトにしてはいけない理由
- 型の最適な決定方法
- インデックスを貼る以外のパフォーマンス向上方法
- 主キーの決め方、主キーはデフォルトのBigintIDではだめなのか
- テーブル名やカラム名の決め方

### この本から学びたいこと
- NULLをデフォルトにしてはいけない理由→達人に学ぶSQLを読む
- 型の最適な決定方法
- インデックスを貼る以外のパフォーマンス向上方法→正規化をしないことで検索パフォーマンスが向上するがデータ整合性とのトレードオフ
- 主キーの決め方、主キーはデフォルトのBigintIDではだめなのか
- テーブル名やカラム名の決め方→テーブル名は複数形にする、複数形にできない場合はなにかがおかしい、カラム名は特に厳密なルールはない
- テーブルを分割する際の決定基準→第3正規形まで

## 読んだあと

### 自分の行動の変化（日々の業務にどう使うか）

- データを削除する場合で外部キーが設定されている場合は、子のデータから順に削除する
- キーのカラムを作成するときは、キーは固定長文字列にする
- NULL許可は可能な限りしない
- 主キーに従属していないカラムがあるなら別テーブルに分ける
- 非キーが非キーに従属してるカラムがあるなら別テーブルに分ける
- 関連エンティティ（中間テーブル）を作る際、そのテーブルのの関心は一つだけにする
- 正規化する理由を問われた際は、メリットはデータ整合性の高さ・更新のパフォーマンス向上で、デメリットは結合による検索のパフォーマンスの悪化と説明する
- B-treeインデックスを貼る際は、レコードが1万件以上のテーブル・カラムの値が全レコードの5％程度の場合（入る値が1か2か3しかない場合で99レコードありそれぞれ33件ずつなら30％になりインデックスは必要ない、カーディナリティという）
  - カーディナリティは複数カラムの組み合わせで考える
  - 特定の値にデータが集中している場合は向いていない、値が平均的に分散しているとベスト
- WHERE句でORを使った場合はインデックスが使用されないのでINを使う
- 主キーとユニークキーにはインデックスを貼る必要がない
- インデックスは更新のパフォーマンスを低下させる、更新するとインデックス情報を更新する処理が走るため
- 一部のカラムの検索回数が多いならそのカラムだけのテーブルも追加で作成する（データマート）、検索パフォーマンスは上がるがデータ整合性が取れなくなる・テーブルを追加するのでストレージを圧迫するデメリットがある
- 合計値などを計算済みで保持しているサマリーテーブルも効果的だが、データマートと同じデメリットがある
- RDBで家系図のような木構造を表現する際は、隣接リストモデル・入れ子集合モデル・入れ子区間モデル・経路列挙モデルのいずれかを使用する

### 新たな疑問点・解消できなかった疑問

- 主キーの決め方、主キーはLaravelデフォルトのBigintIDではだめなのか
　- 代理キーか業務で使用するユニークな文字列どちらを主キーにするべきか、ユニークな文字列がない場合は代理キーを使わずになにかコードを作るべきか
　- キーを固定長文字列にする場合、長さが足りなくなる心配は必要ないか
- 型の最適な決定方法
