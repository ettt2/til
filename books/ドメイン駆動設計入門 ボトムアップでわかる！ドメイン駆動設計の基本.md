# ドメイン駆動設計入門 ボトムアップでわかる！ドメイン駆動設計の基本

## 読む前に,,,

### 理解していること

- サービス層でロジック、リポジトリ層でDBを扱う

### 理解していないこと

- 値オブジェクトやエンティティとはなにか

### この本から学びたいこと

- 値オブジェクト、エンティティとはなにか、他に知らないDDDの要素はなにか
- DDDで扱いやすい設計を実現できるか
  - できるがチームで行うには学習が必要
- LaravelでDDDできるか、できる場合どの様に分けるか（ORMとの兼ね合いなど）
  - なんちゃってクリーンアーキテクチャを実践してみる

## 読んだあと

### 要点・初めて知ったことなど

- ドメインの知識をコードに落としこむことでコードがドキュメントになる

- 値オブジェクト
  - システム固有のある概念の値をオブジェクトとして扱うために作る
  - その値オブジェクトを使用するクラスのインスタンス引数の型として実装する
  - コンストラクタでバリデーションするので不正な値を防いだり誤った代入を防ぐことができる、コンストラクタの記述がその値のルールになる（10文字以上、null不可など）
  - 複雑な値がどういう組み合わせかを記述できる（商品型番とロット番号の組み合わせの値など）
  - 引数の型として使用できるので、プリミティブ型を使う場合に比べて好き勝手に引数を渡されることを防ぐことができる
  - 値に関するロジックは値オブジェクトのクラスに記述する（金額計算など）ことで、その値に関するロジックを一箇所に集中させることができ、ロジックの散在や重複を防ぐことができる
 
- エンティティ
　- 値オブジェクトとの違いはライフサイクルがあるか
    - 作成～削除の流れがある概念はエンティティになる（ユーザーアカウントなど）
    - ただし、タイヤ一つをとっても車にとっては値オブジェクトでタイヤ工場にとってはエンティティになるので、システムによって扱いが変わる
  - エンティティクラスを作成し、インスタンス変数に値オブジェクトのクラスを使用、エンティティクラスに関するロジックを記述する
  ```
  // エンティティのインスタンス変数に値オブジェクトを渡す
  user = new User(new UserName('tanaka'));
  ```

- ドメインサービス
  - 値オブジェクトやエンティティに記述すると不自然になってしまう、ドメインに関するロジックを記述する
  - 例えばユーザーアカウントエンティティの重複確認処理はドメインサービスに記述する
    - エンティティに記述してしまうと、重複しているかを自身に問い合わせることになり、重複しているならtrueを返すのかfalseを返すのか混乱する
  - ドメインサービスは状態を持たない
  - ドメインサービスに何でも記述するとエンティティがドメインモデル貧血症になってしまうので、濫用しない・できるだけ使わない
    - まずはエンティティや値オブジェクトに記述してみて違和感を感じたらドメインサービスに記述するのが良い
    - 4.5章参考
  - 値オブジェクト・エンティティ・ドメインサービスを組み合わせることでユースケースを作成できる
 
- リポジトリ
  - アプリケーションとDB間の操作をリポジトリに記述する（オブジェクトの永続化と再構築）
  - リポジトリはインターフェースで定義して、差し替え可能にする
  - DB操作をリポジトリに分けることでUnitテストでインメモリデータベースを使用したりモックにできるのでテスト容易性が向上する
  - 永続化のメソッドにはidとnameを渡すような実装ではなくUserオブジェクトを渡す

- アプリケーションサービス
  - システムのために実装が必要なロジックであるCRUD処理などのユースケースを記述する
    - ドメインサービスとリポジトリをインスタンス変数として渡し、メソッド内でエンティティや値オブジェクトを使用する
  - メソッド内でエンティティや値オブジェクトといったドメインオブジェクトを返り値とするとドメインオブジェクトをアプリケーションサービスの呼び出し側で操作できてしまうのはドメインオブジェクトの操作が散在してしまうので注意
    - アプリケーションサービス以外からドメインオブジェクトを操作できる状況は防ぎたいので、DTOを経由してドメインオブジェクトを使用する（ドメインオブジェクトを非公開にする）
  - 更新処理で更新したい値が増えるたびに更新メソッドの引数を増やすのはメンテナンス性が悪い
    - コマンドオブジェクトを作成し引数として渡すことで解消
  - アプリケーションサービスにはドメインに関するルールを記述しない
    - 例えばユーザーの重複不可はルールでありドメインの知識なのでアプリケーションサービスに記述しない
    - アプリケーションサービスに重複判定を記述した場合は重複判定のルールが変わった時に複数箇所修正が必要になるが、ドメインオブジェクトに記述すれば一箇所の修正で済む
  - アプリケーションサービスでインターフェースを使用する場合の目的は、フロントエンドエンジニアがバックエンドの実装を待たずして開発を進めてもらうため（モックを作成して開発を進められるため）
  - アプリケーションサービスは状態を持たない
   
- 凝集度
  - インスタンス変数がクラス内の一部のメソッドでしか使用されていない場合は凝集度が低い
  - インスタンス変数が全て使用されているメソッドしか存在しないクラスは凝集度が高い
    - そうすると複数クラスに分けることになるがまとまりがわからなくなるので、パッケージ化する（ディレクトリでまとめる）
   
- ファクトリ
  - エンティティオブジェクトを生成する際に生成処理が複雑になる場合はファクトリを作成する

- トランザクション
  - 一度のトランザクションで保存するオブジェクトは一つに限定し、そのオブジェクトをなるべく小さくすることでトランザクションロックの影響を最小限にするべき

- 集約
  - デメテルの法則でオブジェクトのメソッド呼び出しを制限する
    - 呼びさせるのはオブジェクト自身・引数として渡されたオブジェクト・インスタンス変数・直接インスタンス化したオブジェクト
  - 変更の単位でまとめる、他の集約が他の集約のオブジェクトの操作しない

- コード
  - コードは言葉との齟齬をなくす
    - 30人以上という記述でコード都合で29人などとしない（count > 29ではなくcount >= 30にする、count >= 29ではなくcount + 1 >= 30にする）
   
- 仕様
  - DBの問い合わせが必要な判定処理は仕様クラスに記述する（specificationクラス）
  - 検索条件をリポジトリに記述するとドメイン知識がリポジトリに流出してしまうので、リポジトリで取得した全件を仕様クラスを使用して絞り込みする　リスト13.13
    - ただし全件取得して一つずつ仕様にあっているか確認するのでパフォーマンスの問題がある
    - 書き込み処理はドメインオブジェクトをフル活用するが、取得処理はパフォーマンス維持のためにドメインの考えを緩和することがある
   
- アーキテクチャ
  - UIにドメインオブジェクトに記述されるべきふるまいが記述されるのはスマートUIというアンチパターンなので注意
    - 複数の画面に同じロジックが記述される元になるのでビジネスロジックは一箇所に集約する
　- ドメイン駆動設計にはアーキテクチャの決まりはない
    - レイヤードアーキテクチャでもヘキサゴナルアーキテクチャでもクリーンアーキテクチャでもいい

- 軽量DDD
  - ドメイン駆動設計の書き方だけを取り入れることを軽量DDDという
  - ドメイン駆動設計の目的はドメインの本質に向き合いコードでサポートすること
 
- ユビキタス言語
  - ユビキタス言語でドメインエキスパートと開発者の表現やコードの命名（「ユーザー名を変更する」なのか「名前を変更するなのか」、技術的な表現の「名前を更新する」にしないなど）を揃える
  - 会話の脳内翻訳をなくすことでドメイン概念の曖昧な言葉や扱いにくい言葉に気づくことができる

- 境界づけられたコンテキスト
  - ここでいう境界はドメインの境界
  - 同じものを指しているのに意味が違ったり、違うものを指しているのに言葉が同じものは境界を引ける
  - ECサイトで商品を買うユーザーと、ECサイトのシステムにログインするユーザーは違う
    - 同名のクラスになるのでパッケージで分ける
  - コンテキストを分けることの影響をわかりやすくするためにコンテキストマップを作成して、モデル同士の関係性を把握できるようにする

### 新たな疑問点

- ドメイン駆動設計で使用するパターンは学習できたが、ドメイン駆動設計するためのドメインのモデリングについて知りたい
  - エリック本を読んでみる
